using System;
using System.Collections;
using System.Collections.Generic;
using System.Text.RegularExpressions;
using UnityEngine;
using UnityEngine.UI;

public class GameManager : MonoBehaviour
{
    /* TODO:
        * Need to make comparisons change characters to lower case otherwise logic will fail
        * InputField not working for input - Change to regular text field for now
        * Change graphics depending on guesses left
        * Have a BodyCondition enum state for Audio later on
    */

    #region Private Variables
    
    private string sInput = "";         // holds the player's input text
    public string _wordGuessing = "";  // holds the word generated by WordFactory
    private char[] _alphabetArray       // array of alphabet characters
        = new char[26]
        {
            'a','b','c','d',
            'e','f','g','h',
            'i','j','k','l',
            'm','n','o','p',
            'q','r','s','t',
            'u','v','w','x','y','z'
        };
    private char _currLetter = ' ';     // used to get the character in the player's input
    private int _characterLimit = 1;    // used to assign the character limit in the player input field
    private int _wrongGuessesLeft = 6;  // controls how many guesses the player can get wrong before losing
    private bool _haveReset = true;     // to control times the reset code block functions
    private bool _haveSetGraphic;
    private enum GameState              // enum to define the different states of the game
    { 
        Playing,
        PreGame,
        Paused,
        Won, 
        Lost 
    }

    // state to control method execution that control the game flow and variable setting
    // set to PreGame state at the start of the game launch
    private GameState _gameState = GameState.PreGame;

    // used to store the list of indices the letter is at in the word
    private List<int> _letterPositionIndices = new List<int>();
    #endregion

    // This section is for objects on which the other class scripts are attached to allow for use of their fields and behaviours.
    [Header("Script Objects")]
    public WordFactory wordFactory;     // handles the word generation and manipulation in the game
    public SoundManager soundManager;   // handles the audio in the game

    // This section is for objects that are involved in game play, such as the player input field, hangman graphics, and alphabet.
    [Header("Gameplay Objects")]
    public InputField playerInputField; // text box that gets player keystrokes (set to alphanumeric only)
    public GameObject gamePanel;        // the main panel in which the game takes place
    public GameObject alphabetPanel;    // alphabet letters holder that displays guessed letters
    public GameObject pauseMenuPanel;   // panel for the pause menu
    public GameObject mainMenuPanel;    // panel for the main menu
    public GameObject endGameMenuPanel; // panel for the end game menu
    public GameObject creditsPanel;     // panel for the credits screen
    public Text underscoredWord;        // text object that is updated through gameplay and holds the missing word for the player
    public Text guessesLeftNumberText;  // text that holds the number of guesses left for the player
    public Text endGameTitle;           // text that displays the win/lose message to the player on the End Game Menu
    public Image gallowsImage;          // holds the image that displays the gallows and will change through gameplay
    public Image hangmanImage;          // holds the image that displays the man and will change through gameplay
    public Sprite[] gallowsSprites;     // holds sprites the gallowsImage will be set to at different stages of the game
    public Sprite[] hangmanSprites;     // holds sprites the hangmanImage will be set to at different stages of the game
    public bool easyMode = false, mediumMode = false, hardMode = false; // used to control the difficulty of the word generated
    

    void Start()
    {
        // setting our gallows graphic to the 'Empty' version
        gallowsImage.sprite = gallowsSprites[0];

        // setting our hangman graphic to the 'full body of hangman' version
        hangmanImage.sprite = hangmanSprites[0];
    }

    
    void Update()
    {
        // checking the current state of the game to run code specific to that state
        switch (_gameState)
        {
            case GameState.Playing:
                {
                    // if the player's input field doesn't have focus
                    if (!playerInputField.isFocused)
                    {
                        playerInputField.Select();              // set it to have focus
                        playerInputField.ActivateInputField();  // activate it
                    }

                    // setting to false for next time game state = PreGame
                    _haveReset = false;

                    // label to jump to if the player enters a word they've guessed before
                    //Skip:

                    // if the player has no more incorrect guesses left
                    if (_wrongGuessesLeft == 0)
                    { _gameState = GameState.Lost; }    // tell the game they Lost

                    // if player presses Escape key
                    if (Input.GetKeyDown(KeyCode.Escape))
                    { _gameState = GameState.Paused; }  // tell the game we're in the paused state

                    guessesLeftNumberText.text = _wrongGuessesLeft.ToString();

                    if (!_haveSetGraphic)
                    {
                        // depending on how many incorrect guesses the player has left
                        switch (_wrongGuessesLeft)
                        {
                            // set the graphics to different versions
                            // later on will also set to play different sounds
                            case 5:
                                {
                                    // setting our gallows graphic to its next version
                                    gallowsImage.sprite = gallowsSprites[1];

                                    // setting our hangman graphic to its next version
                                    hangmanImage.sprite = hangmanSprites[1];

                                    // tell the game we have reset the graphics so it doesn't execute every frame
                                    _haveSetGraphic = true;
                                    break;
                                }
                            case 4:
                                {
                                    gallowsImage.sprite = gallowsSprites[2];
                                    hangmanImage.sprite = hangmanSprites[2];
                                    _haveSetGraphic = true;
                                    break;
                                }
                            case 3:
                                {
                                    gallowsImage.sprite = gallowsSprites[3];
                                    hangmanImage.sprite = hangmanSprites[3];
                                    _haveSetGraphic = true;
                                    break;
                                }
                            case 2:
                                {
                                    gallowsImage.sprite = gallowsSprites[4];
                                    hangmanImage.sprite = hangmanSprites[4];
                                    _haveSetGraphic = true;
                                    break;
                                }
                            case 1:
                                {
                                    gallowsImage.sprite = gallowsSprites[5];
                                    hangmanImage.sprite = hangmanSprites[5];
                                    _haveSetGraphic = true;
                                    break;
                                }
                            case 0:
                                {
                                    gallowsImage.sprite = gallowsSprites[6];
                                    _haveSetGraphic = true;
                                    break; 
                                }
                            default:
                                break;
                        }
                    }
                    break;
                }
            case GameState.PreGame:
                {
                    if (!_haveReset)
                    {
                        mainMenuPanel.SetActive(true);  // activate the main menu panel
                        gamePanel.SetActive(false);     // deactivate the game
                        pauseMenuPanel.SetActive(false);// deactivate the pause menu
                        ResetGraphicsAndVariables();    // reset main graphics and variables
                        ResetAlphabetObjects();         // deactivate all letter objects in alphabet panel
                    }
                    break; 
                }
            case GameState.Paused:
                {
                    _haveReset = false;
                    if (!pauseMenuPanel.active)         // if Pause Menu isn't active already
                    { pauseMenuPanel.SetActive(true); } // enable Pause Menu 

                    // set the game to not be interactable while you're paused
                    gamePanel.GetComponent<CanvasGroup>().interactable = false;
                    break;
                }
            case GameState.Won:
                {
                    _haveReset = false;
                    endGameTitle.text = "You Won!";         // set title on end screen to show game result to player

                    StartCoroutine(WaitTwoSeconds());

                    // if End Game Menu AND the credits menu isn't active
                    if (!endGameMenuPanel.activeInHierarchy && !creditsPanel.activeInHierarchy)           
                    { endGameMenuPanel.SetActive(true); }   // enable End Game Menu

                    // if our game is still interactable, reset things specific to this state
                    if (gamePanel.GetComponent<CanvasGroup>().interactable)
                    { 
                        ResetAlphabetObjects();     // deactivate all letter objects in alphabet panel
                        _wrongGuessesLeft = 6;      // reset number of incorrect guesses the player has left

                        sInput = string.Empty;                      // reset the stored input
                        playerInputField.text = string.Empty;       // reset the player InputField's text
                        _wordGuessing = string.Empty;               // reset the word being guessed
                        underscoredWord.text = string.Empty;        // reset the underscored word the player can see
                    }

                    // set the game to not be interactable while you're in the end game menu
                    gamePanel.GetComponent<CanvasGroup>().interactable = false;
                    break; 
                }
            case GameState.Lost:
                {
                    _haveReset = false;
                    endGameTitle.text = "You Lost";         // set title on end screen to show game result to player

                    // set the game to not be interactable while you're in the end game menu
                    gamePanel.GetComponent<CanvasGroup>().interactable = false;

                    StartCoroutine(WaitTwoSeconds());

                    // if End Game Menu isn't active already AND the credits menu isn't active
                    if (!endGameMenuPanel.active && !creditsPanel.activeInHierarchy)
                    { endGameMenuPanel.SetActive(true); }   // enable End Game Menu

                    // if our game is still interactable, reset things specific to this state
                    if (gamePanel.GetComponent<CanvasGroup>().interactable)
                    {
                        ResetAlphabetObjects();     // deactivate all letter objects in alphabet panel
                        _wrongGuessesLeft = 6;      // reset number of incorrect guesses the player has left

                        sInput = string.Empty;                      // reset the stored input
                        playerInputField.text = string.Empty;       // reset the player InputField's text
                        underscoredWord.text = string.Empty;        // reset the underscored word the player can see
                    }

                    // set the game to not be interactable while you're in the end game menu
                    gamePanel.GetComponent<CanvasGroup>().interactable = false;
                    break; 
                }
            default:
                {
                    // something is wrong if this code executes, so reset everything by sending them
                    // back to the Main Menu:

                    if (!_haveReset)
                    {
                        _haveReset = false;
                        gamePanel.GetComponent<CanvasGroup>().interactable = false;
                        _gameState = GameState.PreGame; // setting the state back to pregame
                    }
                    break; 
                }
        }
        
    }

    public void OnInputEnter()
    {
        Debug.Log("OnInputEnter method has been executed.");

        // if we're still playing the game and not in a menu
        if (_gameState == GameState.Playing)
        {
            // assigning our input to the text the player enters without the whitespaces and in lowercase
            sInput = wordFactory.RemoveWhiteSpaces(playerInputField.text).ToLower();

            // if the player's input does not contain anything but alphabet characters
            if (!Regex.IsMatch(sInput, "^[a-z]+$"))
            { playerInputField.text = ""; return; } // set the input field to nothing and exit the method.

            // exit the method if the player didn't enter anything
            if (sInput.Length == 0){ return; }
            else if (sInput.Length == 1)    // else if the player entered 1 character
            {
                // get the first character from their input, in lower case, without whitespaces
                _currLetter = wordFactory.RemoveWhiteSpaces(sInput).ToLower()[0];

                Debug.Log("_currLetter is: " + _currLetter);

                // new List of type Text object same size as number of alphabet Text component objects in hierarchy
                List<Text> letterTextObjects = new List<Text>(alphabetPanel.GetComponentsInChildren<Text>().Length);

                // store all the Text component alphabet letters (entire alphabet in hierarchy)
                letterTextObjects.AddRange(alphabetPanel.GetComponentsInChildren<Text>());

                Debug.Log("Size of letterTextObjects (T.O) list: " + letterTextObjects.Count);

                // loop through the alphabet panel letters
                for (int i = 0; i < letterTextObjects.Count; i++)
                {
                    // if the current letter's gameobject is active (visable in the scene)
                    if (!letterTextObjects[i].gameObject.activeSelf)
                    { letterTextObjects.RemoveAt(i); i--; }
                }

                // loop through our active letters
                for (int i = 0; i < letterTextObjects.Count; i++)
                {
                    // if we find the current letter guessed in the already-active list
                    if (letterTextObjects[i].text.ToLower() == _currLetter.ToString())
                    {
                        // if the current letter isn't 'i', change the letter back to uppercase, else if it is 'i', keep it lowercase
                        letterTextObjects[i].text = (_currLetter != 'i') ? letterTextObjects[i].text.ToUpper() : _currLetter.ToString();
                        Debug.Log("Letter has already been guessed.");  
                        return; // exit the method immediately
                    }
                }

                // if the letter is not in the word the player is guessing (they guessed wrong)
                if (!wordFactory.EvaluateCharacter(_currLetter, _wordGuessing))
                {
                    Debug.Log("Wrong guess, letter not found in word.");
                    _wrongGuessesLeft--;        // decrement wrong guesses left
                    _haveSetGraphic = false;    // tell the game to update the graphics

                    // this enables the letter object at the same index of the character in the alphbet
                    // to show they have guessed the current letter
                    EnableLetter(alphabetPanel, GetAlphabetIndex(_currLetter));

                    Debug.Log("Alphabet index of letter " + GetAlphabetIndex(_currLetter));
                }
                else // if they didn't guess the letter wrong
                {
                    // since we know the letter exists in the word already, we can clear our previous indices
                    _letterPositionIndices.Clear();

                    //  and get the new index(s) position(s) of it in the word
                    _letterPositionIndices = wordFactory.GetIndicesInWord(_currLetter, _wordGuessing);

                    string debug = "";
                    foreach (int index in _letterPositionIndices)
                    {
                        debug += index.ToString() + ", ";
                    }
                    Debug.Log("Indices in list: " + debug);

                    Debug.Log("Word guessing: " + _wordGuessing);
                    // assign new string to word with underscores at index positions replaced with letter
                    string tempUnderscoreWord = ReplaceUnderscoreWithLetter(_wordGuessing, _currLetter);

                    // assign created string to itself with spaces between each letter
                    tempUnderscoreWord = AddSpacesBetweenLetters(tempUnderscoreWord);

                    // set our original text the player will see to the formatted word that includes spaces
                    // and previous underscores, aside from where our guessed letter was
                    underscoredWord.text = tempUnderscoreWord;

                    // enable the letter object in the alphabet panel at the same index of the character in the alphbet
                    EnableLetter(alphabetPanel, GetAlphabetIndex(_currLetter));
                }
            }
            else // otherwise if they entered more than 1 character
            {
                // if the word they entered is the correct word
                if (wordFactory.EvaluateWord(sInput, _wordGuessing))
                { _gameState = GameState.Won; } // tell the game the player Won
                else
                // if incorrect guess, decrement the number of wrong guesses left and tell the game to update the graphics
                { _wrongGuessesLeft--; _haveSetGraphic = false; }   
            }

            // check if underscored word (without spaces) equals the generated word (without spaces)
            // if it does, set game state to 'Won'
            if (wordFactory.RemoveWhiteSpaces(underscoredWord.text) == _wordGuessing)
            {
                StartCoroutine(WaitTwoSeconds());   // wait two seconds to let the player absorb their visual victory
                _gameState = GameState.Won;         // tell the game the player Won
            } 
        }
    }

    public void Resume()
    {
        // set the game to be interactable when you play the game
        gamePanel.GetComponent<CanvasGroup>().interactable = true;
        pauseMenuPanel.SetActive(false);    // deactivate the pause menu
        _gameState = GameState.Playing;     // tell the game we're playing the game
    }

    public void NewGame()
    {
#if UNITY_EDITOR
        ResetGraphicsAndVariables();

        if (easyMode && !mediumMode && !hardMode)
        { _wordGuessing = wordFactory.GenerateWord("easy"); }
        if (mediumMode && !easyMode && !hardMode)
        { _wordGuessing = wordFactory.GenerateWord("moderate"); }
        if (hardMode && !easyMode && !mediumMode)
        { _wordGuessing = wordFactory.GenerateWord("hard"); }
        else
        { _wordGuessing = wordFactory.GenerateWord(); } // set our local word variable to a newly generated word

        // if it's empty here, we ran out of words to generate or something went wrong in the factory
        if (_wordGuessing == string.Empty)
        {
        #if UNITY_EDITOR
            UnityEditor.EditorApplication.ExitPlaymode();
        #endif
            Application.Quit();
        }

        // deactivate all alphabet letter objects
        ResetAlphabetObjects();

        string unityGeneratedUnderscores = "";
        Debug.Log(wordFactory.LetterCount);

        // for every letter in the word, replace it with an underscore and assign our string to the value
        for (int i = 0; i < wordFactory.LetterCount; i++)
        { unityGeneratedUnderscores += "_"; }

        // put whitespace between every letter for presentation
        // and assign our visable text field to the returned string value
        underscoredWord.text = AddSpacesBetweenLetters(unityGeneratedUnderscores);

        Debug.Log(unityGeneratedUnderscores);

        _characterLimit = wordFactory.LetterCount;          // setting the max number of characters player can input (to assist)
        playerInputField.characterLimit = _characterLimit;  // applying it to the InputField

        // set the game to be interactable when you play the game
        gamePanel.GetComponent<CanvasGroup>().interactable = true;

        gamePanel.SetActive(true);          // activate our game
        endGameMenuPanel.SetActive(false);  // deactivate the end game panel
        mainMenuPanel.SetActive(false);     // deactivate the main menu panel
        _gameState = GameState.Playing;     // set our game state to play
        return;
#endif

// IF NOT IN UNITY EDITOR:

        ResetGraphicsAndVariables();

        // set our local word variable to a newly generated word
        _wordGuessing = wordFactory.GenerateWord();

        // if it's empty here, we ran out of words to generate or something went wrong in the factory
        if (_wordGuessing == string.Empty)
        {
#if UNITY_EDITOR
            UnityEditor.EditorApplication.ExitPlaymode();
#endif
            Application.Quit();
        }

        // make all alphabet letter objects not active
        ResetAlphabetObjects();

        string generatedUnderscores = "";

        // for every letter in the word, replace it with an underscore and assign our string to the value
        for (int i = 0; i < wordFactory.LetterCount; i++)
        { generatedUnderscores += "_"; }

        // put whitespace between every letter for presentation
        // and assign our visable text field to the returned string value
        underscoredWord.text = AddSpacesBetweenLetters(generatedUnderscores);

        _characterLimit = wordFactory.LetterCount;          // setting the max number of characters player can input (to assist)
        playerInputField.characterLimit = _characterLimit;  // applying it to the InputField

        // set the game to be interactable when you play the game
        gamePanel.GetComponent<CanvasGroup>().interactable = true;

        gamePanel.SetActive(true);          // activate our game
        endGameMenuPanel.SetActive(false);  // deactivate the end game panel
        mainMenuPanel.SetActive(false);     // deactivate the main menu panel
        _gameState = GameState.Playing;     // set our game state to play
    }

    public void Retry()
    {
        // resetting our gallows graphic
        gallowsImage.sprite = gallowsSprites[0];

        // resetting our hangman graphic
        hangmanImage.sprite = hangmanSprites[0];

        _wordGuessing = wordFactory.GeneratedWord;
        string generatedUnderscores = "";

        // for every letter in the word, replace it with an underscore and assign our string to the value
        for (int i = 0; i < wordFactory.LetterCount; i++)
        { generatedUnderscores += "_"; }

        // put whitespace between every letter for presentation
        // and assign our visable text field to the returned string value
        underscoredWord.text = AddSpacesBetweenLetters(generatedUnderscores);

        _characterLimit = wordFactory.LetterCount;          // setting the max number of characters player can input (to assist)
        playerInputField.characterLimit = _characterLimit;  // applying it to the InputField

        // set the game to be interactable when you play the game
        gamePanel.GetComponent<CanvasGroup>().interactable = true;

        gamePanel.SetActive(true);          // activate our game
        endGameMenuPanel.SetActive(false);  // deactivate the end game panel
        _gameState = GameState.Playing;     // set our game state to play
    }

    public void ExitGame()
    {
    #if UNITY_EDITOR
        UnityEditor.EditorApplication.ExitPlaymode();
    #endif
        Application.Quit();
    }

    public void MainMenu()
    {
        mainMenuPanel.SetActive(true);      // activate the main menu panel
        gamePanel.SetActive(false);         // deactivate our game
        endGameMenuPanel.SetActive(false);  // deactivate the end game panel
        creditsPanel.SetActive(false);      // deactivate credits panel
        _gameState = GameState.PreGame;     // set our game state to pregame
    }  

    public void CreditsScreen()
    {
        creditsPanel.SetActive(true);

        // if we accessed credits screen through end game menu
        if (endGameMenuPanel.activeInHierarchy)
        { endGameMenuPanel.SetActive(false); }  // deactivate the end game menu

    }

    // enables a Text object at an index in a Text array 
    public void EnableLetter(GameObject lettersParentObject_p, int index_p)
    { lettersParentObject_p.GetComponentsInChildren<Text>(true)[index_p].gameObject.SetActive(true); }

    // returns the index of the letter in the alphabet
    public int GetAlphabetIndex(char letter_p)
    {
        int index = 0;
        for (int i = 0; i < _alphabetArray.Length; i++)
        {
            if (_alphabetArray[i] == _currLetter)
            { index = i; }
        }
        return index;
    }

    /// <summary>
    /// Replaces any index the character is at in the word with the letter itself and removes the underscore.
    /// </summary>
    /// <param name="word_p"></param>
    /// <param name="letter_p"></param>
    /// <returns></returns>
    public string ReplaceUnderscoreWithLetter(string word_p, char letter_p)
    {
        word_p = wordFactory.RemoveWhiteSpaces(underscoredWord.text);
        Debug.Log($"Underscored word after spaces removed: {word_p}");
        string halfWord1 = "", halfWord2 = "";
        Debug.Log("Number of times letter is in word: " + _letterPositionIndices.Count);
        foreach (int indexOfLetter in _letterPositionIndices)
        {
            Debug.Log($"Current index of letter: {indexOfLetter}");
            if (indexOfLetter == 0)        // if the index is the first letter
            {
                halfWord2 = word_p.Substring(1);// get the word from after the letter to replace
                word_p = "";                    // set the word to return to nothing
                word_p += letter_p;             // add the letter to replace to the word to return
                word_p += halfWord2;            // append the rest of the word to the replaced letter, to the word returning
            }
            else if (indexOfLetter == word_p.Length-1)   // if the index is the last letter
            {
                halfWord1 = word_p.Substring(0, indexOfLetter);         // get word before letter position

                // word to be returned is the original word minus the character to be replaced
                // and append the letter we're placing on the end as the last letter in the word
                word_p = halfWord1 + letter_p;
            }
            else
            {
                Debug.Log($"Letter at {indexOfLetter}: {word_p.ToCharArray()[indexOfLetter]}.");

                // split the word just before the index of the letter position
                halfWord1 = word_p.Substring(0, indexOfLetter); // half of word before letter position
                halfWord2 = word_p.Substring(indexOfLetter + 1);// half of word after letter position
                halfWord1 += letter_p;          // add letter to end of first half of the word
                word_p = halfWord1 + halfWord2; // join word back together, now including letter placed
            }
        }
        return word_p;  // return the word with its replaced letter(s)
    }

    /// <summary>
    /// Returns the string passed with whitespace between each letter.
    /// </summary>
    /// <param name="word_p"></param>
    /// <returns></returns>
    public string AddSpacesBetweenLetters(string word_p)
    {
        // create a new char array
        char[] wordLetters = new char[word_p.Length];

        // get all the characters of our underscored word into a char array
        wordLetters = word_p.ToCharArray();
        word_p = "";    // empty the temporary underscored word

        // loop as many times as we have letters in the word
        for (int i = 0; i < wordLetters.Length; i++)
        {
            if (i == wordLetters.Length)    // if we're at the last letter index
            { word_p += wordLetters[i]; }   // don't add a space
            word_p += wordLetters[i] + " "; // else, add the character and a space to the word
        }
        return word_p;
    }

    /// <summary>
    /// Resets main variables and graphics in the game. Does not reset local word to guess variable.
    /// </summary>
    public void ResetGraphicsAndVariables()
    {
        // setting our gallows graphic to the 'Empty' version
        gallowsImage.sprite = gallowsSprites[0];

        // setting our hangman graphic to the 'full body of hangman' version
        hangmanImage.sprite = hangmanSprites[0];
        _letterPositionIndices.Clear(); // reset our indices list
        _currLetter = ' ';              // reset the current letter
        sInput = string.Empty;          // reset the recorded player input
        _characterLimit = 1;            // reset character limit
        _wrongGuessesLeft = 6;          // reset number of incorrect guesses the player has left
        _haveReset = true;
    }

    public void ResetAlphabetObjects()
    {
        // new List of type Text object same size as number of alphabet Text component objects in hierarchy
        List<Text> letterTextObjects = new List<Text>(alphabetPanel.GetComponentsInChildren<Text>().Length);

        // store all the Text component alphabet letters (entire alphabet in hierarchy)
        letterTextObjects.AddRange(alphabetPanel.GetComponentsInChildren<Text>());

        // loop through the alphabet panel letters
        for (int i = 0; i < letterTextObjects.Count; i++)
        { letterTextObjects[i].gameObject.SetActive(false); }   // deactivate every letter object
    }

    public IEnumerator WaitTwoSeconds()
    { yield return new WaitForSecondsRealtime(2f); }
}
